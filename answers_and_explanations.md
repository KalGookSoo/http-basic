# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### Chapter 01 인터넷 네트워크

#### [01-1 인터넷 통신](#ans-01-1-인터넷-통신)
- 인터넷이 동작하는 원리와 패킷 교환 방식
- 클라이언트-서버 간 요청/응답 개념
- 네트워크 계층과 OSI 7계층의 개요

#### [01-2 IP(인터넷 프로토콜)](#ans-01-2-ip-인터넷-프로토콜)
- IP 주소의 구조(IPv4/IPv6)
- 라우팅과 서브네팅의 기초 개념
- IP 패킷의 구성 요소(헤더, 페이로드)

#### [01-3 TCP, UDP](#ans-01-3-tcp-udp)
- TCP의 연결지향, 신뢰성, 흐름/혼잡 제어
- UDP의 비연결성, 경량성, 실시간성 장점
- 용도 비교: 파일전송/웹(TCP) vs 스트리밍/게임(UDP)

#### [01-4 PORT](#ans-01-4-port)
- 포트의 역할과 범위(Well-known/Registered/Dynamic)
- 소켓(아이피+포트) 개념과 프로세스 매핑
- 서비스 구분을 위한 포트 사용 예시(HTTP 80, HTTPS 443)

#### [01-5 DNS](#ans-01-5-dns)
- 도메인 네임을 IP로 변환하는 시스템
- 쿼리 흐름: 로컬 캐시 → 리커시브 → 권한 있는 네임서버
- A/AAAA/CNAME/NS 등 주요 레코드 타입

### Chapter 02 URI와 웹 브라우저 요청 흐름

#### [02-1 URI](#ans-02-1-uri)
- URI/URL/URN의 차이
- 스키마, 호스트, 포트, 경로, 쿼리, 프래그먼트 구성
- 인코딩 규칙과 예약 문자

#### [02-2 웹 브라우저 요청 흐름](#ans-02-2-웹-브라우저-요청-흐름)
- 주소창 입력부터 응답 렌더링까지의 단계
- DNS 조회, TCP 핸드셰이크, TLS, HTTP 요청/응답 순서
- 브라우저 캐시, 프리로드/프리페치의 영향

### Chapter 03 HTTP 기본

#### [03-1 모든 것이 HTTP](#ans-03-1-모든-것이-http)
- 웹 문서, 이미지, API, 스트리밍 등 전송 단위로서의 HTTP
- HTTP/1.1, HTTP/2, HTTP/3의 간단 비교
- 프로토콜 독립성과 확장성

#### [03-2 클라이언트 서버 구조](#ans-03-2-클라이언트-서버-구조)
- 역할 분리: 클라이언트(UI/요청) vs 서버(비즈니스/응답)
- 무상태 통신에서의 확장성과 부하 분산
- 프록시, 게이트웨이, 로드밸런서의 위치

#### [03-3 Stateful, Stateless](#ans-03-3-stateful-stateless)
- 상태 유지 vs 비상태의 차이와 장단점
- 세션/쿠키/토큰을 통한 상태 관리 전략
- 확장성, 장애 복구, 캐시 적합성 관점 비교

#### [03-4 비 연결성(connectionless)](#ans-03-4-비-연결성-connectionless)
- 요청-응답 후 연결을 종료하는 특성
- 연결 재사용(keep-alive)과 HTTP/2 멀티플렉싱
- 연결 비용과 지연 시간에 대한 고려

#### [03-5 HTTP 메시지](#ans-03-5-http-메시지)
- 시작줄, 헤더, 바디 구조
- 요청 라인(method, URI, version)과 상태라인(status code)
- 헤더 예시와 바디 포맷(JSON, HTML, Form)

### Chapter 04 HTTP 메서드

#### [04-1 HTTP API를 만들어보자](#ans-04-1-http-api를-만들어보자)
- 리소스 중심 설계: URI는 명사, 행위는 메서드로 구분
- 표준 메서드 활용해 CRUD 매핑하기
- 엔드포인트 버저닝과 문서화 기본

<a id="ans-04-1-http-api를-만들어보자"></a>
## 04-1 HTTP API를 만들어보자 정답 및 해설

### 문제 1
문제: 다음 중 리소스 중심 설계의 원칙으로 옳은 것은?

정답: URI는 명사로 리소스를 식별하고, 행위는 HTTP 메서드로 구분한다

해설:
- 리소스 중심 설계는 URI를 명사로 유지하고, 생성/조회/갱신/삭제 같은 행위는 POST/GET/PUT/PATCH/DELETE로 구분합니다.
- 모든 작업을 GET으로 통일하면 의미 체계가 깨지고 캐시/안전성 특성을 활용할 수 없습니다.
- 상태 전이를 쿼리스트링 액션으로 강제하는 것은 일관성과 캐시성 측면에서 바람직하지 않습니다.

### 문제 2
문제: 다음 중 CRUD와 HTTP 메서드 매핑으로 가장 적절한 것은?

정답: 생성-POST, 조회-GET, 전체 교체-PUT, 삭제-DELETE

해설:
- POST는 보통 컬렉션에 대해 새 리소스를 생성합니다(201 Created + Location 권장).
- GET은 안전하고 캐시 가능하며 서버 상태를 변경하지 않습니다.
- PUT은 전체 교체를 의미하는 멱등적 메서드입니다.
- 삭제는 DELETE가 적절합니다. PATCH는 부분 변경에 사용됩니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: 새 리소스 생성 성공 시 201 Created와 Location 헤더를 보낼 수 있다, PUT은 보통 전체 교체 의미이며 멱등적으로 동작하는 것이 기대된다, 컬렉션은 보통 복수형 URI로 표현하며, 필터/정렬은 쿼리에 둔다

해설:
- 생성 성공 시 201과 Location으로 새 리소스의 주소를 제공하는 것이 관례입니다.
- PUT은 동일 요청을 반복해도 같은 결과가 유지되는 멱등적 성질을 가집니다.
- 컬렉션은 복수형(`/orders`)이 일반적이며, 필터/정렬/페이지네이션은 쿼리로 표현합니다.
- PATCH는 항상 멱등이라고 볼 수 없습니다. 버저닝은 조직/제품 맥락에 맞춰 URI 접두사 또는 미디어 타입 버전 등 다양한 전략이 가능합니다.

#### [04-2 HTTP 메서드 - GET, POST](#ans-04-2-http-메서드-get-post)
- GET: 안전(safe), 멱등(idempotent), 캐시 가능
- POST: 리소스 생성/행위 트리거, 바디 전송
- 사용 시나리오와 캐시/브라우저 동작 차이

<a id="ans-04-2-http-메서드-get-post"></a>
## 04-2 HTTP 메서드 - GET, POST 정답 및 해설

### 문제 1
문제: 다음 중 GET 메서드의 속성에 대한 설명으로 옳은 것은?

정답: 기본적으로 캐시 가능하며 조회에 적합하다

해설:
- GET은 안전하고 멱등적인 조회 메서드로, 적절한 캐시 헤더가 있으면 브라우저/프록시/CDN에서 캐시될 수 있습니다.
- 서버 상태 변경을 유발하지 않는 것이 원칙이며, URL로 표현되므로 링크/북마크에 적합합니다.

### 문제 2
문제: 다음 중 POST 메서드에 대한 설명으로 가장 적절한 것은?

정답: 새 리소스 생성이나 행위 트리거에 사용하며, 보통 메시지 바디로 데이터를 전송한다

해설:
- POST는 생성/커맨드 트리거에 적합하며 멱등이 아닙니다. 동일 요청 반복 시 중복 생성이 발생할 수 있습니다.
- 일반적으로 JSON/폼/멀티파트 등의 바디를 전송합니다. 캐시는 기본적으로 적용되지 않습니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: POST-Redirect-GET 패턴은 폼 재제출을 방지하는 데 도움 된다, GET은 적절한 헤더가 있으면 브라우저/프록시/CDN에서 캐시될 수 있다, POST는 일반적으로 캐시되지 않으며, 중복 제출 방지를 위해 Idempotency-Key 같은 전략을 사용할 수 있다

해설:
- PRG 패턴은 POST 처리 후 303 등으로 결과 페이지를 GET으로 요청하게 하여 새로고침/뒤로가기 시 재제출을 막습니다.
- GET은 ETag/Last-Modified/Cache-Control이 있으면 캐시가 활용됩니다.
- POST는 기본적으로 캐시 대상이 아니며, 멱등이 아니므로 서버 측에서 중복 방지 키로 같은 요청의 중복 처리를 차단할 수 있습니다. 민감 정보는 GET 쿼리에 넣지 않는 것이 안전합니다.

#### [04-3 HTTP 메서드 - PUT, PATCH, DELETE](#ans-04-3-http-메서드-put-patch-delete)
- PUT: 전체 교체, 멱등적 특성
- PATCH: 부분 변경, 멱등성 보장 아님
- DELETE: 삭제, 멱등적 동작 기대

<a id="ans-04-3-http-메서드-put-patch-delete"></a>
## 04-3 HTTP 메서드 - PUT, PATCH, DELETE 정답 및 해설

### 문제 1
문제: 다음 중 PUT에 대한 설명으로 가장 옳은 것은?

정답: 리소스 전체를 주어진 표현으로 교체하며 멱등적 동작이 기대된다

해설:
- PUT은 동일 요청을 반복해도 최종 리소스 상태가 같아야 하는 멱등 메서드입니다.
- 전체 교체를 의미하는 것이 일반적이며, 존재하지 않을 때 생성 허용 여부는 정책에 따릅니다(허용 시 201 + Location 가능).
- 안전(safe)한 메서드는 아니며 서버 상태를 변경할 수 있습니다.

### 문제 2
문제: 다음 중 PATCH에 대한 설명으로 옳은 것은?

정답: PATCH는 부분 변경에 적합하며 멱등이 아닐 수 있다

해설:
- PATCH는 리소스의 일부 필드만 변경할 때 사용합니다.
- Merge Patch(application-merge-patch+json)는 필드 병합/삭제 규칙을 사용하고, JSON Patch(application-json-patch+json)는 연산 목록으로 변경을 명시합니다.
- 멱등성은 문서의 의미에 따라 달라질 수 있으므로 일반적으로 보장하지 않습니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: DELETE는 멱등적 동작이 기대된다, If-Match와 ETag를 사용하면 경쟁 상황에서 갱신 충돌을 방지할 수 있다, PATCH는 application-json-patch+json 같은 미디어 타입을 사용할 수 있다

해설:
- DELETE는 이미 삭제된 리소스에 대해 다시 호출해도 최종 상태가 동일하므로 멱등 동작이 기대됩니다(응답 코드는 정책에 따라 204/404 등 가능).
- 조건부 갱신은 ETag/If-Match로 구현하며, 불일치 시 412로 충돌을 방지합니다.
- JSON Patch는 application-json-patch+json 미디어 타입을 사용합니다. Merge Patch는 application-merge-patch+json을 사용합니다.
- PUT은 존재하지 않을 때 항상 404만 반환해야 하는 것은 아닙니다(업서트 정책이 허용되면 201 가능). 204 No Content에는 바디를 포함하지 않습니다.

#### [04-4 HTTP 메서드의 속성](#ans-04-4-http-메서드의-속성)
- 안전성(Safe), 멱등성(Idempotent), 캐시가능성(Cacheable)
- 조건부 요청과 병행 제어와의 연계
- 부작용과 재시도 전략 고려

<a id="ans-04-4-http-메서드의-속성"></a>
## 04-4 HTTP 메서드의 속성 정답 및 해설

### 문제 1
문제: Safe/Idempotent/Cacheable에 대한 설명으로 옳은 것은?

정답: Safe는 서버 상태를 변경하지 않는 의미적 속성이다

해설:
- Safe는 의미상 상태 변화를 일으키지 않는 메서드에 대한 속성입니다(GET/HEAD/OPTIONS 등). 로깅처럼 부수효과가 있어도 의미는 유지됩니다.
- 멱등은 같은 요청을 여러 번 보내도 최종 리소스 상태가 같음을 뜻합니다. 응답 본문이 항상 동일해야 한다는 뜻이 아닙니다.
- Cacheable은 모든 메서드에 동일하게 적용되지 않습니다. 일반적으로 GET/HEAD가 캐시 대상입니다.

### 문제 2
문제: 조건부 요청과 멱등성/재시도에 관한 설명으로 가장 적절한 것은?

정답: PUT에 If-Match를 사용하면 네트워크 오류 재시도 시에도 중복 갱신을 줄이는 데 도움이 된다

해설:
- If-Match는 갱신 전 조건을 검사해, ETag가 일치할 때만 변경을 허용함으로써 경쟁 상태에서의 충돌을 412로 방지합니다.
- If-None-Match는 주로 캐시 검증(읽기) 또는 생성 시 중복 방지를 위해 사용됩니다.
- 304 Not Modified는 If-None-Match나 If-Modified-Since 흐름의 결과입니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: GET은 Safe이며 멱등이고 캐시 가능하다, DELETE는 멱등적 동작이 기대된다, POST는 일반적으로 비멱등이며 Idempotency-Key로 중복 생성을 줄일 수 있다

해설:
- GET은 Safe/Idempotent/Cacheable의 대표입니다.
- DELETE는 최종 상태(리소스 부재)가 동일하므로 멱등적 동작이 기대됩니다(응답 코드는 다를 수 있음).
- POST는 일반적으로 비멱등이며, 결제/생성과 같은 작업에 Idempotency-Key를 사용해 중복을 억제할 수 있습니다.
- PUT은 멱등이지만 Safe는 아닙니다(서버 상태를 변경). PATCH는 항상 멱등이라고 볼 수 없습니다.

### Chapter 05 HTTP 메서드 활용

#### [05-1 클라이언트에서 서버로 데이터 전송]()
- 쿼리 파라미터 vs 메시지 바디의 용도 차이
- 폼 전송(application/x-www-form-urlencoded, multipart)
- JSON 전송과 콘텐츠 타입 지정

#### [05-2 HTTP API 설계 예시]()
- 컬렉션/개별 리소스 URI 패턴
- 계층 관계와 하위 리소스 표현
- 오류 응답 포맷과 상태코드 매핑

### Chapter 06 HTTP 상태코드

#### [06-1 HTTP 상태코드 소개]()
- 1xx/2xx/3xx/4xx/5xx 범주 개요
- 의미 체계와 표준 문서(RFC) 레퍼런스
- 애플리케이션 수준 규약의 필요성

#### [06-2 2xx - 성공]()
- 200 OK, 201 Created, 204 No Content 차이
- 생성 위치 전달(Location 헤더) 관례
- 멱등 요청에서의 응답 처리

#### [06-3 3xx - 리다이렉션1]()
- 301 Moved Permanently, 302 Found 의미
- 303 See Other와 POST-Redirect-GET 패턴
- 304 Not Modified의 캐시 최적화

#### [06-4 3xx - 리다이렉션2]()
- 307 Temporary Redirect, 308 Permanent Redirect
- 메서드 보존 여부와 브라우저 동작 차이
- SEO와 링크 유지 전략

#### [06-5 4xx - 클라이언트 오류, 5xx - 서버 오류]()
- 400/401/403/404 주요 케이스
- 409/412/429 등 상황별 선택 가이드
- 500/502/503/504 서버 장애 대응

### Chapter 07 HTTP 헤더1 - 일반 헤더

#### [07-1 HTTP 헤더 개요]()
- 엔티티/표현/요청/응답 헤더의 분류
- 표준 vs 커스텀 헤더 네이밍 규칙
- 대소문자 비민감성과 전송 형식

#### [07-2 표현]()
- Content-Type, Content-Length, Content-Encoding
- 언어/문자셋: Content-Language, charset
- 표현 메타데이터와 협상 기반

#### [07-3 콘텐츠 협상]()
- Accept, Accept-Language, Accept-Encoding
- 서버 선호도(q 값)와 최적 표현 선택
- Vary 헤더와 캐시 안정성

#### [07-4 전송 방식]()
- 전송 인코딩(chunked)과 지속 연결
- 범위 요청(Range)과 재개 다운로드
- 압축 전송과 성능 최적화

#### [07-5 일반 정보]()
- Date, Server, Via 등 정보성 헤더
- Referrer-Policy, User-Agent 이해
- Retry-After와 재시도 제어

#### [07-6 특별한 정보]()
- Host, Origin, Location의 역할
- ETag/If-Match로 조건부 갱신
- Allow, Content-Location 활용

#### [07-7 인증]()
- WWW-Authenticate, Authorization 동작
- Basic vs Bearer 토큰 흐름
- 인증/인가와 상태관리 연계

#### [07-8 쿠키]()
- Set-Cookie, Cookie 포맷과 속성(Path, Domain, Secure, HttpOnly, SameSite)
- 세션 유지와 추적, 보안 고려사항
- 쿠키와 토큰 기반 인증 비교

### Chapter 08 HTTP 헤더2 - 캐시와 조건부 요청

<a id="ans-02-2-웹-브라우저-요청-흐름"></a>
## 02-2 웹 브라우저 요청 흐름 정답 및 해설

### 문제 1
문제: 주소창에 https://www.example.com 을 입력했을 때 올바른 단계 순서는?

정답: DNS 조회 → TCP → TLS → HTTP → 렌더링

해설:
- 일반적인 흐름은 이름 해석(DNS) 후 전송 계층 연결(TCP), 그 위에서 보안 채널 성립(TLS), 애플리케이션 계층 통신(HTTP), 마지막으로 파싱/렌더링 단계가 이어집니다.
- TLS는 TCP 위에서 동작하므로 TLS가 TCP보다 먼저 올 수 없습니다.

### 문제 2
문제: 다음 중 성능 최적화 기법과 설명의 연결이 올바른 것은?

정답: preload: 현재 페이지에 필요한 리소스를 우선 로드한다

해설:
- preconnect는 DNS/TCP/TLS까지 미리 수행하는 것이며, prerender가 "다음 페이지를 미리 렌더링" 개념에 가깝습니다.
- dns-prefetch는 DNS 조회만 선행합니다.
- prefetch는 미래 네비게이션을 위한 낮은 우선순위의 사전 로드입니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: TLS 1.3은 핸드셰이크 왕복 횟수를 줄여 초기 지연을 낮춘다, HTTP/2는 하나의 TCP 연결에서 여러 요청을 동시에 보낼 수 있다, 브라우저는 캐시가 적중하면 네트워크를 거치지 않고 응답을 제공할 수 있다, 301/308 리다이렉션은 영구 이동을 의미한다

해설:
- TLS 1.3은 1-RTT(재방문 시 0-RTT 가능)로 초기 지연을 개선합니다.
- HTTP/2는 멀티플렉싱으로 단일 연결에서 동시 스트림을 처리합니다.
- CSS는 일반적으로 렌더 차단 요소이므로 "차단 요소가 아니다"라는 문장은 틀립니다.
- 캐시 적중 시 네트워크 없이 응답을 제공할 수 있으며, 조건부 요청 후 304로 검증될 수도 있습니다.
- 301/308은 영구 이동으로, 302/303/307은 일시 이동 계열입니다.

#### [08-1 캐시 기본 동작]()
- 캐시 적중(hit)/미스(miss) 흐름
- 유효기간과 신선도 지표(age, max-age)
- 개인/공용 캐시 구분

#### [08-2 검증 헤더와 조건부 요청]()
- ETag/If-None-Match 흐름
- Last-Modified/If-Modified-Since 비교
- 조건부 갱신과 대역폭 절감

#### [08-3 캐시와 조건부 요청 헤더]()
- Cache-Control 지시어(no-store, no-cache, max-age, s-maxage)
- Expires, Pragma와의 관계
- Revalidation 전략(강제/약한)

#### [08-4 프록시 캐시]()
- 프록시 캐시와 CDN의 역할
- s-maxage, stale-while-revalidate 등 활용
- 공용 캐시 검증과 무결성

#### [08-5 캐시 무효화]()
- 강제 무효화와 재검증 트리거
- Surrogate-Key/Tag 기반 무효화
- 캐시 파기 정책과 주의점

<a id="ans-01-1-인터넷-통신"></a>
## 01-1 인터넷 통신 정답 및 해설

### 문제 1
문제: 인터넷에서 대용량 데이터를 작은 단위로 나누어 전달하는 방식은 무엇인가?

정답: 패킷 교환(Packet Switching)

해설: 현대 인터넷은 회선 전체를 한 통신이 독점하는 회선 교환이 아니라, 데이터를 작은 패킷으로 나누어 링크 자원을 공유하는 패킷 교환 방식을 사용합니다. 분실된 패킷만 재전송할 수 있어 효율과 신뢰성이 높습니다.

### 문제 2
문제: 다음 중 TCP/IP 모델에서 IP가 속한 계층은?

정답: 인터넷층(Internet)

해설: IP는 주소 지정과 라우팅을 담당하는 프로토콜로 TCP/IP 모델의 인터넷층에 속합니다. 전송층에는 TCP/UDP가 위치합니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: 인터넷은 주로 패킷 교환 방식을 사용한다; OSI의 응용/표현/세션 계층은 TCP/IP의 응용층으로 대응된다; TCP는 손실 패킷 재전송과 혼잡 제어를 통해 신뢰성을 높인다

해설:
- 인터넷은 패킷 교환 방식을 사용하므로 회선을 독점하지 않습니다.
- OSI 7계층의 응용/표현/세션은 TCP/IP 모델에서 응용층으로 포괄됩니다.
- TCP는 재전송, 순서 보장, 혼잡 제어로 신뢰성을 제공합니다. UDP는 비연결성으로 경량/저지연이 장점이며 순서 보장을 제공하지 않습니다.



<a id="ans-01-2-ip-인터넷-프로토콜"></a>
## 01-2 IP(인터넷 프로토콜) 정답 및 해설

### 문제 1
문제: 다음 중 사설 IPv4 대역이 아닌 것은?

정답: 203.0.113.0/24

해설: 사설 IPv4 대역은 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 입니다. 203.0.113.0/24는 문서/예시용(TEST-NET-3, RFC 5737) 대역으로, 사설 대역이 아닙니다.

### 문제 2
문제: IPv4 헤더의 TTL 필드가 0이 되었을 때 올바른 설명은?

정답: 패킷은 라우터에서 폐기될 수 있으며, ICMP 메시지가 생성될 수 있다

해설: TTL은 각 홉(라우터)을 지날 때마다 1씩 감소하며 0이 되면 패킷은 폐기됩니다. 라우터는 일반적으로 송신자에게 ICMP Time Exceeded 메시지를 보냅니다.

### 문제 3 (복수 응답)
문제: 다음 중 NAT 동작과 관련하여 옳은 것을 모두 고르시오.

정답: 사설 IP를 공인 IP로 변환해 여러 단말이 인터넷을 공유할 수 있다; 포트 주소 변환(PAT)을 통해 다수의 연결을 하나의 공인 IP에 매핑할 수 있다; NAT 환경에서도 포트 포워딩을 통해 내부 서버에 대한 외부 접속을 허용할 수 있다

해설:
- NAT는 사설→공인 주소 변환을 통해 다수 단말의 인터넷 공유를 가능케 합니다.
- PAT는 소스 포트를 변환해 다수의 세션을 하나의 공인 IP에 매핑합니다.
- 포트 포워딩 설정으로 외부에서 내부 서버로의 접근을 허용할 수 있습니다.
- NAT는 IPv6에서 필수는 아닙니다(전역 주소 공간이 넓음). 또한 NAT는 ARP의 대체 기술이 아닙니다(ARP는 동일 망에서 IP→MAC 해석 담당).

<a id="ans-01-3-tcp-udp"></a>
## 01-3 TCP, UDP 정답 및 해설

### 문제 1
문제: TCP 3-way 핸드셰이크의 올바른 순서는?

정답: SYN → SYN-ACK → ACK

해설: 클라이언트가 SYN으로 시작하고, 서버가 SYN-ACK로 응답, 마지막으로 클라이언트가 ACK를 보내며 연결이 성립됩니다.

### 문제 2
문제: 다음 중 TCP가 제공하는 기능은?

정답: 순서 보장과 재전송 메커니즘

해설: TCP는 순서 보장과 ACK/재전송을 제공합니다. 브로드캐스트/멀티캐스트는 기본 제공하지 않으며, 핸드셰이크 없이 전송하는 것은 UDP의 특성입니다.

### 문제 3 (복수 응답)
문제: 다음 중 UDP의 특징과 활용에 대해 옳은 것을 모두 고르시오.

정답: 연결 설정 없이 전송하며 오버헤드가 낮다; 실시간 스트리밍이나 온라인 게임에 자주 사용된다; DNS 질의에 흔히 사용된다

해설:
- UDP는 비연결형으로 지연과 오버헤드가 낮습니다.
- 약간의 손실을 허용하는 실시간 애플리케이션에서 자주 사용됩니다.
- DNS 쿼리는 보통 UDP를 사용합니다(단, 큰 응답이나 특수 상황에서 TCP 사용 가능). HTTP/3는 QUIC(UDP 기반)이므로 "UDP와 무관"이 아닙니다.

<a id="ans-01-4-port"></a>
## 01-4 PORT 정답 및 해설

### 문제 1
문제: 포트 범위 분류에 대한 설명으로 옳은 것은?

정답: Dynamic Ephemeral은 49152~65535 이다

해설: IANA 권장 에페머럴 포트 범위는 49152~65535입니다. Well-known은 0~1023, Registered는 1024~49151입니다. 운영체제 기본 범위는 다를 수 있으나 개념적으로는 이 구분을 따릅니다.

### 문제 2
문제: 다음 중 소켓과 연결 식별에 대한 올바른 설명은?

정답: 클라이언트는 에페머럴 포트를 사용해 각 연결을 구분한다; 같은 서버 포트로 동시에 여러 연결이 가능한 이유는 소스 IP와 포트가 달라 4튜플이 고유하기 때문이다

해설:
- 서버의 한 리스닝 포트에도 다수의 동시 연결을 처리할 수 있습니다. 각 연결은 소스 IP/포트가 달라 4튜플로 구분됩니다.
- 연결의 고유 식별을 IP 주소만으로 할 수는 없습니다. 포트와 전송 프로토콜까지 포함해야 합니다.

### 문제 3 (복수 응답)
문제: NAT와 포트 포워딩에 대해 옳은 것을 모두 고르시오.

정답: PAT는 소스 포트를 변경해 여러 내부 연결을 하나의 공인 IP에 매핑한다; 외부에서 내부 웹 서버로 접근하려면 포트 포워딩 등 매핑 규칙이 필요하다; 같은 공인 IP의 서로 다른 포트에 서로 다른 내부 서비스(포트)를 매핑할 수 있다

해설:
- PAT는 포트 번호를 변환해 다수의 내부 세션을 하나의 공인 IP로 구분합니다.
- 외부 접근을 위해서는 NAT 장비에서 공인 IP의 특정 포트를 내부 IP:포트로 포워딩해야 합니다.
- NAT 환경에서도 포트는 핵심 개념이며, DNS는 보통 UDP 53을 사용하지만 항상 TCP 53만을 사용하는 것은 아닙니다. 상황에 따라 TCP도 사용됩니다.


<a id="ans-01-5-dns"></a>
## 01-5 DNS 정답 및 해설

### 문제 1
문제: DNS 조회 흐름에 대한 설명으로 옳은 것은?

정답: 리커시브 리졸버는 최종 응답을 얻기 위해 루트→TLD→권한 서버를 순회할 수 있다

해설: 일반적으로 브라우저/OS의 스텁 리졸버는 로컬/리커시브 리졸버에 재귀 요청을 보내고, 리커시브 리졸버가 루트→TLD→권한 서버를 따라가며 최종 응답을 구해 캐시한 뒤 반환합니다. 브라우저가 직접 루트에 질의하지 않습니다. NS 레코드는 네임서버 권한 위임 정보를 담으며, TTL은 캐싱 동작에 큰 영향을 줍니다.

### 문제 2
문제: 다음 중 레코드 타입과 설명의 연결이 올바른 것은?

정답: MX: 메일 수신 서버 도메인을 지정한다

해설: MX는 메일 교환 서버 도메인을 지정하며 우선순위를 포함합니다. CNAME은 IP를 직접 제공하지 않고 정식 이름으로 별칭을 연결합니다. TXT는 SPF/도메인 검증 등 텍스트를 담고, SOA는 존의 시작 정보와 시리얼/타이머 등을 담습니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: 일반 DNS 질의는 보통 UDP 53을 사용한다; 큰 응답이거나 영역 전송은 TCP 53이 사용될 수 있다; TTL이 짧으면 변경 사항이 더 빠르게 전파된다

해설:
- 보통의 질의/응답은 지연과 오버헤드를 줄이기 위해 UDP 53으로 수행됩니다(EDNS로 확장 가능).
- 응답이 크거나 영역 전송(AXFR/IXFR) 같은 작업에는 TCP 53이 사용될 수 있습니다.
- TTL이 짧으면 캐시 유효기간이 짧아져 변경 전파가 빨라집니다. CNAME과 A를 동일 이름에 동시에 둘 수는 없습니다. 리커시브 리졸버는 성능 향상을 위해 응답을 캐시합니다.


<a id="ans-02-1-uri"></a>
## 02-1 URI 정답 및 해설

### 문제 1
문제: 다음 중 URI의 구성 요소에 대한 설명으로 옳은 것은?

정답: 스키마와 호스트는 대소문자를 구분하지 않는다

해설:
- 프래그먼트는 클라이언트 전용으로 서버 라우팅에 사용되지 않으며 HTTP 요청에 포함되지 않습니다.
- `userinfo`는 보안/로그 노출 문제로 웹에서 사용이 권장되지 않습니다.
- 쿼리에서 `&`, `=`는 구분자로 쓰이므로 값에 포함할 때는 퍼센트 인코딩해야 합니다.
- 스키마와 호스트는 대소문자를 구분하지 않습니다. 반면 경로는 서버 구현에 따라 대소문자를 구분할 수 있습니다.

### 문제 2
문제: 다음 중 퍼센트 인코딩과 관련하여 옳은 것은?

정답: `/` 문자는 경로 구분자이므로 값으로 쓰려면 `%2F`로 인코딩해야 한다

해설:
- 공백은 일반적으로 `%20`로 인코딩합니다. `+`는 application/x-www-form-urlencoded의 쿼리 컨텍스트에서 공백처럼 해석될 수 있지만 RFC3986 일반 규칙 그 자체는 아닙니다.
- `/`는 경로 구분자이며, 값에 포함하려면 `%2F`로 인코딩해야 안전합니다.
- 한글 등 비ASCII 문자는 UTF-8 바이트로 퍼센트 인코딩해야 합니다.
- 프래그먼트는 서버로 전송되지 않으므로 서버 보관 전 디코딩 요구사항이 성립하지 않습니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: URL은 URI의 부분집합이다, URN은 리소스 위치가 바뀌어도 동일 식별자로 쓸 수 있다, 경로는 리소스 식별, 쿼리는 필터/정렬/페이징 등 옵션에 적합하다, 호스트에 한글 도메인을 사용할 때 내부적으로 Punycode가 사용될 수 있다

해설:
- URL ⊂ URI: URL은 위치를 나타내는 URI의 한 종류입니다.
- URN은 위치와 독립적인 이름입니다(예: ISBN). 위치 변경과 무관하게 동일 식별자가 유지됩니다.
- 경로는 리소스를 식별하고, 쿼리는 필터/정렬/페이지네이션 같은 옵션 전달에 적합합니다.
- HTTPS의 기본 포트는 443으로, 80은 HTTP의 기본 포트입니다.
- 국제화 도메인 이름(IDN)은 Punycode로 변환되어 DNS에 전송됩니다.


<a id="ans-03-1-모든-것이-http"></a>
## 03-1 모든 것이 HTTP 정답 및 해설

### 문제 1
문제: 다음 중 "모든 것이 HTTP" 관점에 대한 설명으로 옳은 것은?

정답: HTTP는 다양한 리소스(문서/이미지/폰트/JSON/비디오 세그먼트)를 동일한 요청-응답 모델로 전송할 수 있다

해설:
- 현대 웹에서는 HTML/CSS/JS뿐 아니라 이미지, 폰트, JSON API, 동영상 세그먼트(HLS/DASH) 등 대부분을 HTTP로 전송합니다.
- 전용 실시간 프로토콜(WebRTC 등)이 존재하지만, 대규모 분배는 HTTP 기반 세그먼트 전송이 주류입니다.

### 문제 2
문제: 다음 중 HTTP/1.1, HTTP/2, HTTP/3 비교에 대한 설명으로 옳은 것은?

정답: HTTP/3는 QUIC(UDP 기반) 위에서 동작해 전송 계층 HOL 문제를 완화한다

해설:
- HTTP/2는 단일 TCP 연결 내 멀티플렉싱을 제공하지만 TCP의 HOL 문제는 남습니다.
- HTTP/3는 QUIC 위에서 스트림 독립성을 제공해 손실 시 다른 스트림의 블로킹을 줄입니다.
- HTTP/1.1은 keep-alive로 연결 재사용을 지원합니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: MIME 타입은 HTTP 메시지의 바디 포맷을 식별하는 데 사용된다, HTTP는 애플리케이션 계층 프로토콜로서 하위 전송 계층 교체에도 메시지 의미가 유지될 수 있다, 콘텐츠 협상은 Accept-* 헤더를 통해 클라이언트 선호 표현을 전달하는 메커니즘이다, 범위 요청(Range)은 대용량 미디어 전송 최적화에 활용될 수 있다

해설:
- Content-Type은 바디의 미디어 타입을 나타냅니다.
- HTTP는 애플리케이션 계층 프로토콜로, HTTP/1.1/2(TCP)와 HTTP/3(QUIC) 모두에서 동일 의미 체계를 유지합니다.
- Accept, Accept-Language, Accept-Encoding 등은 선호 표현을 전달해 서버가 최적 표현을 선택하도록 돕습니다.
- Range 요청과 206 Partial Content는 대용량/스트리밍에 유용합니다. HTTP 자체는 상태 저장을 보장하지 않으며, 상태 관리는 쿠키/세션/토큰 등 상위 레이어에서 수행됩니다.


<a id="ans-03-2-클라이언트-서버-구조"></a>
## 03-2 클라이언트 서버 구조 정답 및 해설

### 문제 1
문제: 클라이언트-서버 구조에 대한 설명으로 옳은 것은?

정답: 클라이언트는 요청을 보내고 응답을 렌더링하며, 서버는 로직 처리와 데이터 연동을 담당한다

해설:
- 클라이언트는 UI와 상호작용을 담당하고, 서버는 비즈니스 로직과 데이터 저장소 접근을 담당합니다.
- 서버가 항상 이전 요청 상태를 기억해야 하는 것은 아닙니다. HTTP의 기본은 무상태이며, 필요 시 외부 세션 스토어/토큰으로 상태를 관리합니다.

### 문제 2
문제: 무상태 통신과 확장성에 대한 설명으로 옳은 것은?

정답: 무상태는 어느 서버 인스턴스가 응답해도 되므로 로드 밸런싱에 유리하다

해설:
- 무상태는 요청 간 상태 의존이 없으므로 어떤 서버가 응답해도 결과가 일관됩니다.
- 이는 수평 확장과 장애 시 트래픽 전환을 단순화합니다.
- 무상태가 캐시를 어렵게 만드는 것이 아니라, 오히려 캐시 친화적인 특성을 제공합니다.
- 인증은 토큰 기반 등으로 무상태 방식에서 충분히 가능합니다.

### 문제 3 (복수 응답)
문제: 다음 중 프록시/게이트웨이/로드 밸런서에 대해 옳은 것을 모두 고르시오.

정답: 포워드 프록시는 보통 클라이언트 측에 위치해 외부 접속을 제어한다, 리버스 프록시는 서버 앞단에서 캐시, 압축, TLS 종료 등을 담당할 수 있다, 로드 밸런서는 여러 서버로 트래픽을 분산한다, API 게이트웨이는 인증/인가, 레이트 리밋, 라우팅 같은 기능을 제공할 수 있다

해설:
- 포워드 프록시는 기업망 등에서 클라이언트의 아웃바운드 트래픽을 제어/캐시합니다.
- 리버스 프록시는 서버 앞단에서 SSL 종료, 캐시, 압축, 보안(WAF) 등 엣지 기능을 수행합니다.
- 로드 밸런서는 다수 인스턴스로 트래픽을 분산합니다.
- 게이트웨이는 이기종 프로토콜 변환/정책 집행을 포함할 수 있으며 반드시 "동일 프로토콜만"을 의미하지 않습니다. API 게이트웨이는 인증/인가, 레이트 리밋, 라우팅을 제공합니다.



<a id="ans-03-3-stateful-stateless"></a>
## 03-3 Stateful, Stateless 정답 및 해설

### 문제 1
문제: 다음 중 Stateless 통신의 장점으로 옳은 것은?

정답: 요청마다 필요한 컨텍스트를 포함하므로 어느 서버가 처리해도 일관된다

해설:
- Stateless는 서버가 이전 상태에 의존하지 않으므로 어떤 인스턴스가 처리해도 결과가 동일합니다.
- 이는 수평 확장과 장애 전환(한 서버 장애 시 다른 서버로 라우팅)에 유리합니다.
- 반대로 상태가 특정 서버에 묶이면(스티키/로컬 세션) 장애 전환과 부하 분산이 어려워집니다.
- 무상태는 응답 결정 요소가 명시적이어서 CDN/프록시 캐시에 유리합니다.

### 문제 2
문제: 다음 중 상태 관리 방식과 설명의 연결이 올바른 것은?

정답: 스티키 세션: 동일 사용자를 항상 동일 서버로 라우팅하는 방식이다

해설:
- 서버 세션은 "토큰 자체에 모든 상태"가 있는 것이 아니라, 세션 ID만 쿠키에 있고 실제 상태는 서버 측 스토어에 저장합니다.
- JWT(토큰)는 즉시 회수가 어려운 편이며, 중앙 저장소가 필수는 아닙니다(서명 검증으로 무상태 가능). 다만 블랙리스트/회전 등으로 보완합니다.
- 스티키 세션은 로드 밸런서가 동일 사용자의 요청을 특정 서버로 고정시키는 방식입니다.
- 세션 외부화는 공유 스토어(예: Redis)에 세션을 저장하여 어느 서버에서나 조회 가능하게 합니다. 로컬 분산 저장이 아닙니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: SameSite 쿠키 설정은 CSRF 위험을 줄이는 데 도움 된다, HttpOnly 속성은 자바스크립트에서 쿠키 접근을 차단해 XSS 피해 완화를 돕는다, Stateless 설계는 캐시 친화적이다, 토큰 기반 인증은 짧은 만료/회전 전략과 함께 사용할 수 있다

해설:
- SameSite=Lax/Strict는 크로스 사이트 컨텍스트에서 쿠키 전송을 제한해 CSRF 위험을 낮춥니다.
- HttpOnly는 JS에서 쿠키 접근을 막아 XSS 시 탈취 위험을 낮춥니다(완전한 대책은 아님).
- Stateless는 응답 결정 요소가 명시적이어서 프록시/CDN 캐시에 유리합니다.
- 토큰은 만료를 짧게 하고, 리프레시 토큰/회전/블랙리스트로 보완할 수 있습니다.
- 스티키 세션은 확장성과 장애 전환에 항상 유리하지 않습니다. 특정 서버에 의존성이 생깁니다.

<a id="ans-03-4-비-연결성-connectionless"></a>
## 03-4 비 연결성(connectionless) 정답 및 해설

### 문제 1
문제: HTTP의 "비 연결성"에 대한 설명으로 옳은 것은?

정답: HTTP는 요청-응답 단위로 상태를 보관하지 않으며, 연결은 재사용할 수도 끊을 수도 있다

해설:
- 비 연결성은 TCP가 비연결형이라는 뜻이 아니라, HTTP가 프로토콜 차원에서 이전 요청 상태를 유지하지 않음을 의미합니다.
- HTTP/1.0 시대에는 요청마다 연결을 열고 닫는 패턴이 일반적이었습니다. 현대에는 keep-alive로 재사용이 보편적입니다.
- HTTP/1.0은 멀티플렉싱을 지원하지 않습니다. 멀티플렉싱은 HTTP/2부터 도입되었습니다.

### 문제 2
문제: 다음 중 연결 비용과 최적화에 대한 설명으로 옳은 것은?

정답: 새로운 TCP 연결은 슬로우 스타트로 인해 초반 전송 윈도우가 작다

해설:
- TLS 1.3은 1-RTT로 핸드셰이크 RTT를 줄였고, 재방문 시 0-RTT도 가능하여 항상 느리다고 볼 수 없습니다.
- 프리커넥트는 DNS뿐 아니라 TCP/TLS까지 선행할 수 있습니다. dns-prefetch가 DNS만 미리 수행합니다.
- HTTP/1.1은 기본이 지속 연결이며, Connection: keep-alive로 재사용됩니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: HTTP/2는 하나의 TCP 연결에서 여러 요청을 동시 전송할 수 있다, HTTP/3는 QUIC 기반으로 스트림 간 독립성이 높다, 연결 재사용은 TLS 핸드셰이크 비용을 줄이는 데 도움이 된다

해설:
- HTTP/2의 멀티플렉싱은 단일 TCP 연결에서 동시 스트림을 가능케 합니다.
- HTTP/3는 QUIC 기반으로 스트림 독립성이 높아 손실 시 다른 스트림의 HOL 영향을 줄입니다.
- 연결 재사용은 새로운 TLS 핸드셰이크를 피하고 TCP 슬로우 스타트 재시작도 줄여 성능에 이롭습니다.
- 도메인 샤딩은 HTTP/2 시대에는 일반적으로 비권장입니다(단일 연결 멀티플렉싱이 유리).
- 비 연결성은 서버에 세션을 메모리에 저장한다는 뜻이 아닙니다. 이는 상태 관리 전략과 별개입니다.


<a id="ans-03-5-http-메시지"></a>
## 03-5 HTTP 메시지 정답 및 해설

### 문제 1
문제: HTTP 메시지 구조에 대한 설명으로 옳은 것은?

정답: 시작줄 다음에는 헤더들이 오고, 빈 줄 이후에 바디가 온다

해설:
- HTTP 메시지는 시작줄 → 헤더들 → 빈 줄(CRLF 2회) → 바디 순서로 구성됩니다.
- 요청/응답 모두 헤더 없이 바디만 존재하지 않으며, 헤더 종료는 CRLF 2회로 표시합니다. 요청의 시작줄은 메서드로 시작하고, 응답은 상태코드가 아닌 프로토콜 버전으로 시작합니다.

### 문제 2
문제: 다음 중 요청 라인과 상태 라인에 대한 설명이 옳은 것은?

정답: 요청 라인의 request-target은 보통 origin-form이며 경로와 쿼리를 포함할 수 있다

해설:
- 요청 라인은 Method SP Request-Target SP HTTP-Version 구조이며, 일반 브라우저 요청은 origin-form("/path?query")을 사용합니다.
- 상태 라인은 HTTP-Version SP Status-Code SP Reason-Phrase 구조입니다. Reason-Phrase는 선택적이며 의미 해석에 의존하지 않는 것이 원칙입니다.
- 제시된 오답의 순서는 서로 뒤바뀌었거나 요소가 잘못되었습니다.

### 문제 3 (복수 응답)
문제: 다음 중 메시지 바디 전송과 관련하여 옳은 것을 모두 고르시오.

정답: Content-Length는 바디의 바이트 길이를 나타낸다, Transfer-Encoding: chunked는 바디 길이를 모를 때 청크로 전송할 수 있게 한다, application/x-www-form-urlencoded는 키-값 쌍을 `&`로 연결해 전송한다, multipart/form-data는 파일 업로드에 자주 사용된다

해설:
- Content-Length는 바디 크기를 명시합니다.
- chunked 인코딩은 길이를 미리 모를 때 유용하며 각 청크는 16진 길이로 시작합니다. HTTP/2 이상에서는 전송 프레이밍으로 대체되므로 Transfer-Encoding 헤더를 사용하지 않습니다.
- application/x-www-form-urlencoded는 키-값을 `&`로 연결합니다. multipart/form-data는 파일 업로드 등 복합 데이터에 적합합니다.

<a id="ans-02-2-웹-브라우저-요청-흐름"></a>
## 02-2 웹 브라우저 요청 흐름 정답 및 해설

### 문제 1
문제: 주소창에 https://www.example.com 을 입력했을 때 올바른 단계 순서는?

정답: DNS 조회 → TCP → TLS → HTTP → 렌더링

해설:
- 일반적인 흐름은 이름 해석(DNS) 후 전송 계층 연결(TCP), 그 위에서 보안 채널 성립(TLS), 애플리케이션 계층 통신(HTTP), 마지막으로 파싱/렌더링 단계가 이어집니다.
- TLS는 TCP 위에서 동작하므로 TLS가 TCP보다 먼저 올 수 없습니다.

### 문제 2
문제: 다음 중 성능 최적화 기법과 설명의 연결이 올바른 것은?

정답: preload: 현재 페이지에 필요한 리소스를 우선 로드한다

해설:
- preconnect는 DNS/TCP/TLS까지 미리 수행하는 것이며, prerender가 "다음 페이지를 미리 렌더링" 개념에 가깝습니다.
- dns-prefetch는 DNS 조회만 선행합니다.
- prefetch는 미래 네비게이션을 위한 낮은 우선순위의 사전 로드입니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: TLS 1.3은 핸드셰이크 왕복 횟수를 줄여 초기 지연을 낮춘다, HTTP/2는 하나의 TCP 연결에서 여러 요청을 동시에 보낼 수 있다, 브라우저는 캐시가 적중하면 네트워크를 거치지 않고 응답을 제공할 수 있다, 301/308 리다이렉션은 영구 이동을 의미한다

해설:
- TLS 1.3은 1-RTT(재방문 시 0-RTT 가능)로 초기 지연을 개선합니다.
- HTTP/2는 멀티플렉싱으로 단일 연결에서 동시 스트림을 처리합니다.
- CSS는 일반적으로 렌더 차단 요소이므로 "차단 요소가 아니다"라는 문장은 틀립니다.
- 캐시 적중 시 네트워크 없이 응답을 제공할 수 있으며, 조건부 요청 후 304로 검증될 수도 있습니다.
- 301/308은 영구 이동으로, 302/303/307은 일시 이동 계열입니다.

#### [08-1 캐시 기본 동작]()
- 캐시 적중(hit)/미스(miss) 흐름
- 유효기간과 신선도 지표(age, max-age)
- 개인/공용 캐시 구분
