# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### Chapter 01 인터넷 네트워크

#### [01-1 인터넷 통신](#ans-01-1-인터넷-통신)
- 인터넷이 동작하는 원리와 패킷 교환 방식
- 클라이언트-서버 간 요청/응답 개념
- 네트워크 계층과 OSI 7계층의 개요

#### [01-2 IP(인터넷 프로토콜)](#ans-01-2-ip-인터넷-프로토콜)
- IP 주소의 구조(IPv4/IPv6)
- 라우팅과 서브네팅의 기초 개념
- IP 패킷의 구성 요소(헤더, 페이로드)

#### [01-3 TCP, UDP](#ans-01-3-tcp-udp)
- TCP의 연결지향, 신뢰성, 흐름/혼잡 제어
- UDP의 비연결성, 경량성, 실시간성 장점
- 용도 비교: 파일전송/웹(TCP) vs 스트리밍/게임(UDP)

#### [01-4 PORT]()
- 포트의 역할과 범위(Well-known/Registered/Dynamic)
- 소켓(아이피+포트) 개념과 프로세스 매핑
- 서비스 구분을 위한 포트 사용 예시(HTTP 80, HTTPS 443)

#### [01-5 DNS]()
- 도메인 네임을 IP로 변환하는 시스템
- 쿼리 흐름: 로컬 캐시 → 리커시브 → 권한 있는 네임서버
- A/AAAA/CNAME/NS 등 주요 레코드 타입

### Chapter 02 URI와 웹 브라우저 요청 흐름

#### [02-1 URI]()
- URI/URL/URN의 차이
- 스키마, 호스트, 포트, 경로, 쿼리, 프래그먼트 구성
- 인코딩 규칙과 예약 문자

#### [02-2 웹 브라우저 요청 흐름]()
- 주소창 입력부터 응답 렌더링까지의 단계
- DNS 조회, TCP 핸드셰이크, TLS, HTTP 요청/응답 순서
- 브라우저 캐시, 프리로드/프리페치의 영향

### Chapter 03 HTTP 기본

#### [03-1 모든 것이 HTTP]()
- 웹 문서, 이미지, API, 스트리밍 등 전송 단위로서의 HTTP
- HTTP/1.1, HTTP/2, HTTP/3의 간단 비교
- 프로토콜 독립성과 확장성

#### [03-2 클라이언트 서버 구조]()
- 역할 분리: 클라이언트(UI/요청) vs 서버(비즈니스/응답)
- 무상태 통신에서의 확장성과 부하 분산
- 프록시, 게이트웨이, 로드밸런서의 위치

#### [03-3 Stateful, Stateless]()
- 상태 유지 vs 비상태의 차이와 장단점
- 세션/쿠키/토큰을 통한 상태 관리 전략
- 확장성, 장애 복구, 캐시 적합성 관점 비교

#### [03-4 비 연결성(connectionless)]()
- 요청-응답 후 연결을 종료하는 특성
- 연결 재사용(keep-alive)과 HTTP/2 멀티플렉싱
- 연결 비용과 지연 시간에 대한 고려

#### [03-5 HTTP 메시지]()
- 시작줄, 헤더, 바디 구조
- 요청 라인(method, URI, version)과 상태라인(status code)
- 헤더 예시와 바디 포맷(JSON, HTML, Form)

### Chapter 04 HTTP 메서드

#### [04-1 HTTP API를 만들어보자]()
- 리소스 중심 설계: URI는 명사, 행위는 메서드로 구분
- 표준 메서드 활용해 CRUD 매핑하기
- 엔드포인트 버저닝과 문서화 기본

#### [04-2 HTTP 메서드 - GET, POST]()
- GET: 안전(safe), 캐시 가능, 멱등성(idempotent) X
- POST: 리소스 생성/행위 트리거, 바디 전송
- 사용 시나리오와 캐시/브라우저 동작 차이

#### [04-3 HTTP 메서드 - PUT, PATCH, DELETE]()
- PUT: 전체 교체, 멱등적 특성
- PATCH: 부분 변경, 멱등성 보장 아님
- DELETE: 삭제, 멱등적 동작 기대

#### [04-4 HTTP 메서드의 속성]()
- 안전성(Safe), 멱등성(Idempotent), 캐시가능성(Cacheable)
- 조건부 요청과 병행 제어와의 연계
- 부작용과 재시도 전략 고려

### Chapter 05 HTTP 메서드 활용

#### [05-1 클라이언트에서 서버로 데이터 전송]()
- 쿼리 파라미터 vs 메시지 바디의 용도 차이
- 폼 전송(application/x-www-form-urlencoded, multipart)
- JSON 전송과 콘텐츠 타입 지정

#### [05-2 HTTP API 설계 예시]()
- 컬렉션/개별 리소스 URI 패턴
- 계층 관계와 하위 리소스 표현
- 오류 응답 포맷과 상태코드 매핑

### Chapter 06 HTTP 상태코드

#### [06-1 HTTP 상태코드 소개]()
- 1xx/2xx/3xx/4xx/5xx 범주 개요
- 의미 체계와 표준 문서(RFC) 레퍼런스
- 애플리케이션 수준 규약의 필요성

#### [06-2 2xx - 성공]()
- 200 OK, 201 Created, 204 No Content 차이
- 생성 위치 전달(Location 헤더) 관례
- 멱등 요청에서의 응답 처리

#### [06-3 3xx - 리다이렉션1]()
- 301 Moved Permanently, 302 Found 의미
- 303 See Other와 POST-Redirect-GET 패턴
- 304 Not Modified의 캐시 최적화

#### [06-4 3xx - 리다이렉션2]()
- 307 Temporary Redirect, 308 Permanent Redirect
- 메서드 보존 여부와 브라우저 동작 차이
- SEO와 링크 유지 전략

#### [06-5 4xx - 클라이언트 오류, 5xx - 서버 오류]()
- 400/401/403/404 주요 케이스
- 409/412/429 등 상황별 선택 가이드
- 500/502/503/504 서버 장애 대응

### Chapter 07 HTTP 헤더1 - 일반 헤더

#### [07-1 HTTP 헤더 개요]()
- 엔티티/표현/요청/응답 헤더의 분류
- 표준 vs 커스텀 헤더 네이밍 규칙
- 대소문자 비민감성과 전송 형식

#### [07-2 표현]()
- Content-Type, Content-Length, Content-Encoding
- 언어/문자셋: Content-Language, charset
- 표현 메타데이터와 협상 기반

#### [07-3 콘텐츠 협상]()
- Accept, Accept-Language, Accept-Encoding
- 서버 선호도(q 값)와 최적 표현 선택
- Vary 헤더와 캐시 안정성

#### [07-4 전송 방식]()
- 전송 인코딩(chunked)과 지속 연결
- 범위 요청(Range)과 재개 다운로드
- 압축 전송과 성능 최적화

#### [07-5 일반 정보]()
- Date, Server, Via 등 정보성 헤더
- Referrer-Policy, User-Agent 이해
- Retry-After와 재시도 제어

#### [07-6 특별한 정보]()
- Host, Origin, Location의 역할
- ETag/If-Match로 조건부 갱신
- Allow, Content-Location 활용

#### [07-7 인증]()
- WWW-Authenticate, Authorization 동작
- Basic vs Bearer 토큰 흐름
- 인증/인가와 상태관리 연계

#### [07-8 쿠키]()
- Set-Cookie, Cookie 포맷과 속성(Path, Domain, Secure, HttpOnly, SameSite)
- 세션 유지와 추적, 보안 고려사항
- 쿠키와 토큰 기반 인증 비교

### Chapter 08 HTTP 헤더2 - 캐시와 조건부 요청

#### [08-1 캐시 기본 동작]()
- 캐시 적중(hit)/미스(miss) 흐름
- 유효기간과 신선도 지표(age, max-age)
- 개인/공용 캐시 구분

#### [08-2 검증 헤더와 조건부 요청]()
- ETag/If-None-Match 흐름
- Last-Modified/If-Modified-Since 비교
- 조건부 갱신과 대역폭 절감

#### [08-3 캐시와 조건부 요청 헤더]()
- Cache-Control 지시어(no-store, no-cache, max-age, s-maxage)
- Expires, Pragma와의 관계
- Revalidation 전략(강제/약한)

#### [08-4 프록시 캐시]()
- 프록시 캐시와 CDN의 역할
- s-maxage, stale-while-revalidate 등 활용
- 공용 캐시 검증과 무결성

#### [08-5 캐시 무효화]()
- 강제 무효화와 재검증 트리거
- Surrogate-Key/Tag 기반 무효화
- 캐시 파기 정책과 주의점

<a id="ans-01-1-인터넷-통신"></a>
## 01-1 인터넷 통신 정답 및 해설

### 문제 1
문제: 인터넷에서 대용량 데이터를 작은 단위로 나누어 전달하는 방식은 무엇인가?

정답: 패킷 교환(Packet Switching)

해설: 현대 인터넷은 회선 전체를 한 통신이 독점하는 회선 교환이 아니라, 데이터를 작은 패킷으로 나누어 링크 자원을 공유하는 패킷 교환 방식을 사용합니다. 분실된 패킷만 재전송할 수 있어 효율과 신뢰성이 높습니다.

### 문제 2
문제: 다음 중 TCP/IP 모델에서 IP가 속한 계층은?

정답: 인터넷층(Internet)

해설: IP는 주소 지정과 라우팅을 담당하는 프로토콜로 TCP/IP 모델의 인터넷층에 속합니다. 전송층에는 TCP/UDP가 위치합니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: 인터넷은 주로 패킷 교환 방식을 사용한다; OSI의 응용/표현/세션 계층은 TCP/IP의 응용층으로 대응된다; TCP는 손실 패킷 재전송과 혼잡 제어를 통해 신뢰성을 높인다

해설:
- 인터넷은 패킷 교환 방식을 사용하므로 회선을 독점하지 않습니다.
- OSI 7계층의 응용/표현/세션은 TCP/IP 모델에서 응용층으로 포괄됩니다.
- TCP는 재전송, 순서 보장, 혼잡 제어로 신뢰성을 제공합니다. UDP는 비연결성으로 경량/저지연이 장점이며 순서 보장을 제공하지 않습니다.



<a id="ans-01-2-ip-인터넷-프로토콜"></a>
## 01-2 IP(인터넷 프로토콜) 정답 및 해설

### 문제 1
문제: 다음 중 사설 IPv4 대역이 아닌 것은?

정답: 203.0.113.0/24

해설: 사설 IPv4 대역은 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 입니다. 203.0.113.0/24는 문서/예시용(TEST-NET-3, RFC 5737) 대역으로, 사설 대역이 아닙니다.

### 문제 2
문제: IPv4 헤더의 TTL 필드가 0이 되었을 때 올바른 설명은?

정답: 패킷은 라우터에서 폐기될 수 있으며, ICMP 메시지가 생성될 수 있다

해설: TTL은 각 홉(라우터)을 지날 때마다 1씩 감소하며 0이 되면 패킷은 폐기됩니다. 라우터는 일반적으로 송신자에게 ICMP Time Exceeded 메시지를 보냅니다.

### 문제 3 (복수 응답)
문제: 다음 중 NAT 동작과 관련하여 옳은 것을 모두 고르시오.

정답: 사설 IP를 공인 IP로 변환해 여러 단말이 인터넷을 공유할 수 있다; 포트 주소 변환(PAT)을 통해 다수의 연결을 하나의 공인 IP에 매핑할 수 있다; NAT 환경에서도 포트 포워딩을 통해 내부 서버에 대한 외부 접속을 허용할 수 있다

해설:
- NAT는 사설→공인 주소 변환을 통해 다수 단말의 인터넷 공유를 가능케 합니다.
- PAT는 소스 포트를 변환해 다수의 세션을 하나의 공인 IP에 매핑합니다.
- 포트 포워딩 설정으로 외부에서 내부 서버로의 접근을 허용할 수 있습니다.
- NAT는 IPv6에서 필수는 아닙니다(전역 주소 공간이 넓음). 또한 NAT는 ARP의 대체 기술이 아닙니다(ARP는 동일 망에서 IP→MAC 해석 담당).

<a id="ans-01-3-tcp-udp"></a>
## 01-3 TCP, UDP 정답 및 해설

### 문제 1
문제: TCP 3-way 핸드셰이크의 올바른 순서는?

정답: SYN → SYN-ACK → ACK

해설: 클라이언트가 SYN으로 시작하고, 서버가 SYN-ACK로 응답, 마지막으로 클라이언트가 ACK를 보내며 연결이 성립됩니다.

### 문제 2
문제: 다음 중 TCP가 제공하는 기능은?

정답: 순서 보장과 재전송 메커니즘

해설: TCP는 순서 보장과 ACK/재전송을 제공합니다. 브로드캐스트/멀티캐스트는 기본 제공하지 않으며, 핸드셰이크 없이 전송하는 것은 UDP의 특성입니다.

### 문제 3 (복수 응답)
문제: 다음 중 UDP의 특징과 활용에 대해 옳은 것을 모두 고르시오.

정답: 연결 설정 없이 전송하며 오버헤드가 낮다; 실시간 스트리밍이나 온라인 게임에 자주 사용된다; DNS 질의에 흔히 사용된다

해설:
- UDP는 비연결형으로 지연과 오버헤드가 낮습니다.
- 약간의 손실을 허용하는 실시간 애플리케이션에서 자주 사용됩니다.
- DNS 쿼리는 보통 UDP를 사용합니다(단, 큰 응답이나 특수 상황에서 TCP 사용 가능). HTTP/3는 QUIC(UDP 기반)이므로 "UDP와 무관"이 아닙니다.
