# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### Chapter 01 인터넷 네트워크

#### [01-1 인터넷 통신](#ans-01-1-인터넷-통신)
- 인터넷이 동작하는 원리와 패킷 교환 방식
- 클라이언트-서버 간 요청/응답 개념
- 네트워크 계층과 OSI 7계층의 개요

#### [01-2 IP(인터넷 프로토콜)](#ans-01-2-ip-인터넷-프로토콜)
- IP 주소의 구조(IPv4/IPv6)
- 라우팅과 서브네팅의 기초 개념
- IP 패킷의 구성 요소(헤더, 페이로드)

#### [01-3 TCP, UDP](#ans-01-3-tcp-udp)
- TCP의 연결지향, 신뢰성, 흐름/혼잡 제어
- UDP의 비연결성, 경량성, 실시간성 장점
- 용도 비교: 파일전송/웹(TCP) vs 스트리밍/게임(UDP)

#### [01-4 PORT](#ans-01-4-port)
- 포트의 역할과 범위(Well-known/Registered/Dynamic)
- 소켓(아이피+포트) 개념과 프로세스 매핑
- 서비스 구분을 위한 포트 사용 예시(HTTP 80, HTTPS 443)

#### [01-5 DNS](#ans-01-5-dns)
- 도메인 네임을 IP로 변환하는 시스템
- 쿼리 흐름: 로컬 캐시 → 리커시브 → 권한 있는 네임서버
- A/AAAA/CNAME/NS 등 주요 레코드 타입

### Chapter 02 URI와 웹 브라우저 요청 흐름

#### [02-1 URI](#ans-02-1-uri)
- URI/URL/URN의 차이
- 스키마, 호스트, 포트, 경로, 쿼리, 프래그먼트 구성
- 인코딩 규칙과 예약 문자

#### [02-2 웹 브라우저 요청 흐름](#ans-02-2-웹-브라우저-요청-흐름)
- 주소창 입력부터 응답 렌더링까지의 단계
- DNS 조회, TCP 핸드셰이크, TLS, HTTP 요청/응답 순서
- 브라우저 캐시, 프리로드/프리페치의 영향

### Chapter 03 HTTP 기본

#### [03-1 모든 것이 HTTP]()
- 웹 문서, 이미지, API, 스트리밍 등 전송 단위로서의 HTTP
- HTTP/1.1, HTTP/2, HTTP/3의 간단 비교
- 프로토콜 독립성과 확장성

#### [03-2 클라이언트 서버 구조]()
- 역할 분리: 클라이언트(UI/요청) vs 서버(비즈니스/응답)
- 무상태 통신에서의 확장성과 부하 분산
- 프록시, 게이트웨이, 로드밸런서의 위치

#### [03-3 Stateful, Stateless]()
- 상태 유지 vs 비상태의 차이와 장단점
- 세션/쿠키/토큰을 통한 상태 관리 전략
- 확장성, 장애 복구, 캐시 적합성 관점 비교

#### [03-4 비 연결성(connectionless)]()
- 요청-응답 후 연결을 종료하는 특성
- 연결 재사용(keep-alive)과 HTTP/2 멀티플렉싱
- 연결 비용과 지연 시간에 대한 고려

#### [03-5 HTTP 메시지]()
- 시작줄, 헤더, 바디 구조
- 요청 라인(method, URI, version)과 상태라인(status code)
- 헤더 예시와 바디 포맷(JSON, HTML, Form)

### Chapter 04 HTTP 메서드

#### [04-1 HTTP API를 만들어보자]()
- 리소스 중심 설계: URI는 명사, 행위는 메서드로 구분
- 표준 메서드 활용해 CRUD 매핑하기
- 엔드포인트 버저닝과 문서화 기본

#### [04-2 HTTP 메서드 - GET, POST]()
- GET: 안전(safe), 캐시 가능, 멱등성(idempotent) X
- POST: 리소스 생성/행위 트리거, 바디 전송
- 사용 시나리오와 캐시/브라우저 동작 차이

#### [04-3 HTTP 메서드 - PUT, PATCH, DELETE]()
- PUT: 전체 교체, 멱등적 특성
- PATCH: 부분 변경, 멱등성 보장 아님
- DELETE: 삭제, 멱등적 동작 기대

#### [04-4 HTTP 메서드의 속성]()
- 안전성(Safe), 멱등성(Idempotent), 캐시가능성(Cacheable)
- 조건부 요청과 병행 제어와의 연계
- 부작용과 재시도 전략 고려

### Chapter 05 HTTP 메서드 활용

#### [05-1 클라이언트에서 서버로 데이터 전송]()
- 쿼리 파라미터 vs 메시지 바디의 용도 차이
- 폼 전송(application/x-www-form-urlencoded, multipart)
- JSON 전송과 콘텐츠 타입 지정

#### [05-2 HTTP API 설계 예시]()
- 컬렉션/개별 리소스 URI 패턴
- 계층 관계와 하위 리소스 표현
- 오류 응답 포맷과 상태코드 매핑

### Chapter 06 HTTP 상태코드

#### [06-1 HTTP 상태코드 소개]()
- 1xx/2xx/3xx/4xx/5xx 범주 개요
- 의미 체계와 표준 문서(RFC) 레퍼런스
- 애플리케이션 수준 규약의 필요성

#### [06-2 2xx - 성공]()
- 200 OK, 201 Created, 204 No Content 차이
- 생성 위치 전달(Location 헤더) 관례
- 멱등 요청에서의 응답 처리

#### [06-3 3xx - 리다이렉션1]()
- 301 Moved Permanently, 302 Found 의미
- 303 See Other와 POST-Redirect-GET 패턴
- 304 Not Modified의 캐시 최적화

#### [06-4 3xx - 리다이렉션2]()
- 307 Temporary Redirect, 308 Permanent Redirect
- 메서드 보존 여부와 브라우저 동작 차이
- SEO와 링크 유지 전략

#### [06-5 4xx - 클라이언트 오류, 5xx - 서버 오류]()
- 400/401/403/404 주요 케이스
- 409/412/429 등 상황별 선택 가이드
- 500/502/503/504 서버 장애 대응

### Chapter 07 HTTP 헤더1 - 일반 헤더

#### [07-1 HTTP 헤더 개요]()
- 엔티티/표현/요청/응답 헤더의 분류
- 표준 vs 커스텀 헤더 네이밍 규칙
- 대소문자 비민감성과 전송 형식

#### [07-2 표현]()
- Content-Type, Content-Length, Content-Encoding
- 언어/문자셋: Content-Language, charset
- 표현 메타데이터와 협상 기반

#### [07-3 콘텐츠 협상]()
- Accept, Accept-Language, Accept-Encoding
- 서버 선호도(q 값)와 최적 표현 선택
- Vary 헤더와 캐시 안정성

#### [07-4 전송 방식]()
- 전송 인코딩(chunked)과 지속 연결
- 범위 요청(Range)과 재개 다운로드
- 압축 전송과 성능 최적화

#### [07-5 일반 정보]()
- Date, Server, Via 등 정보성 헤더
- Referrer-Policy, User-Agent 이해
- Retry-After와 재시도 제어

#### [07-6 특별한 정보]()
- Host, Origin, Location의 역할
- ETag/If-Match로 조건부 갱신
- Allow, Content-Location 활용

#### [07-7 인증]()
- WWW-Authenticate, Authorization 동작
- Basic vs Bearer 토큰 흐름
- 인증/인가와 상태관리 연계

#### [07-8 쿠키]()
- Set-Cookie, Cookie 포맷과 속성(Path, Domain, Secure, HttpOnly, SameSite)
- 세션 유지와 추적, 보안 고려사항
- 쿠키와 토큰 기반 인증 비교

### Chapter 08 HTTP 헤더2 - 캐시와 조건부 요청

<a id="ans-02-2-웹-브라우저-요청-흐름"></a>
## 02-2 웹 브라우저 요청 흐름 정답 및 해설

### 문제 1
문제: 주소창에 https://www.example.com 을 입력했을 때 올바른 단계 순서는?

정답: DNS 조회 → TCP → TLS → HTTP → 렌더링

해설:
- 일반적인 흐름은 이름 해석(DNS) 후 전송 계층 연결(TCP), 그 위에서 보안 채널 성립(TLS), 애플리케이션 계층 통신(HTTP), 마지막으로 파싱/렌더링 단계가 이어집니다.
- TLS는 TCP 위에서 동작하므로 TLS가 TCP보다 먼저 올 수 없습니다.

### 문제 2
문제: 다음 중 성능 최적화 기법과 설명의 연결이 올바른 것은?

정답: preload: 현재 페이지에 필요한 리소스를 우선 로드한다

해설:
- preconnect는 DNS/TCP/TLS까지 미리 수행하는 것이며, prerender가 "다음 페이지를 미리 렌더링" 개념에 가깝습니다.
- dns-prefetch는 DNS 조회만 선행합니다.
- prefetch는 미래 네비게이션을 위한 낮은 우선순위의 사전 로드입니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: TLS 1.3은 핸드셰이크 왕복 횟수를 줄여 초기 지연을 낮춘다, HTTP/2는 하나의 TCP 연결에서 여러 요청을 동시에 보낼 수 있다, 브라우저는 캐시가 적중하면 네트워크를 거치지 않고 응답을 제공할 수 있다, 301/308 리다이렉션은 영구 이동을 의미한다

해설:
- TLS 1.3은 1-RTT(재방문 시 0-RTT 가능)로 초기 지연을 개선합니다.
- HTTP/2는 멀티플렉싱으로 단일 연결에서 동시 스트림을 처리합니다.
- CSS는 일반적으로 렌더 차단 요소이므로 "차단 요소가 아니다"라는 문장은 틀립니다.
- 캐시 적중 시 네트워크 없이 응답을 제공할 수 있으며, 조건부 요청 후 304로 검증될 수도 있습니다.
- 301/308은 영구 이동으로, 302/303/307은 일시 이동 계열입니다.

#### [08-1 캐시 기본 동작]()
- 캐시 적중(hit)/미스(miss) 흐름
- 유효기간과 신선도 지표(age, max-age)
- 개인/공용 캐시 구분

#### [08-2 검증 헤더와 조건부 요청]()
- ETag/If-None-Match 흐름
- Last-Modified/If-Modified-Since 비교
- 조건부 갱신과 대역폭 절감

#### [08-3 캐시와 조건부 요청 헤더]()
- Cache-Control 지시어(no-store, no-cache, max-age, s-maxage)
- Expires, Pragma와의 관계
- Revalidation 전략(강제/약한)

#### [08-4 프록시 캐시]()
- 프록시 캐시와 CDN의 역할
- s-maxage, stale-while-revalidate 등 활용
- 공용 캐시 검증과 무결성

#### [08-5 캐시 무효화]()
- 강제 무효화와 재검증 트리거
- Surrogate-Key/Tag 기반 무효화
- 캐시 파기 정책과 주의점

<a id="ans-01-1-인터넷-통신"></a>
## 01-1 인터넷 통신 정답 및 해설

### 문제 1
문제: 인터넷에서 대용량 데이터를 작은 단위로 나누어 전달하는 방식은 무엇인가?

정답: 패킷 교환(Packet Switching)

해설: 현대 인터넷은 회선 전체를 한 통신이 독점하는 회선 교환이 아니라, 데이터를 작은 패킷으로 나누어 링크 자원을 공유하는 패킷 교환 방식을 사용합니다. 분실된 패킷만 재전송할 수 있어 효율과 신뢰성이 높습니다.

### 문제 2
문제: 다음 중 TCP/IP 모델에서 IP가 속한 계층은?

정답: 인터넷층(Internet)

해설: IP는 주소 지정과 라우팅을 담당하는 프로토콜로 TCP/IP 모델의 인터넷층에 속합니다. 전송층에는 TCP/UDP가 위치합니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: 인터넷은 주로 패킷 교환 방식을 사용한다; OSI의 응용/표현/세션 계층은 TCP/IP의 응용층으로 대응된다; TCP는 손실 패킷 재전송과 혼잡 제어를 통해 신뢰성을 높인다

해설:
- 인터넷은 패킷 교환 방식을 사용하므로 회선을 독점하지 않습니다.
- OSI 7계층의 응용/표현/세션은 TCP/IP 모델에서 응용층으로 포괄됩니다.
- TCP는 재전송, 순서 보장, 혼잡 제어로 신뢰성을 제공합니다. UDP는 비연결성으로 경량/저지연이 장점이며 순서 보장을 제공하지 않습니다.



<a id="ans-01-2-ip-인터넷-프로토콜"></a>
## 01-2 IP(인터넷 프로토콜) 정답 및 해설

### 문제 1
문제: 다음 중 사설 IPv4 대역이 아닌 것은?

정답: 203.0.113.0/24

해설: 사설 IPv4 대역은 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 입니다. 203.0.113.0/24는 문서/예시용(TEST-NET-3, RFC 5737) 대역으로, 사설 대역이 아닙니다.

### 문제 2
문제: IPv4 헤더의 TTL 필드가 0이 되었을 때 올바른 설명은?

정답: 패킷은 라우터에서 폐기될 수 있으며, ICMP 메시지가 생성될 수 있다

해설: TTL은 각 홉(라우터)을 지날 때마다 1씩 감소하며 0이 되면 패킷은 폐기됩니다. 라우터는 일반적으로 송신자에게 ICMP Time Exceeded 메시지를 보냅니다.

### 문제 3 (복수 응답)
문제: 다음 중 NAT 동작과 관련하여 옳은 것을 모두 고르시오.

정답: 사설 IP를 공인 IP로 변환해 여러 단말이 인터넷을 공유할 수 있다; 포트 주소 변환(PAT)을 통해 다수의 연결을 하나의 공인 IP에 매핑할 수 있다; NAT 환경에서도 포트 포워딩을 통해 내부 서버에 대한 외부 접속을 허용할 수 있다

해설:
- NAT는 사설→공인 주소 변환을 통해 다수 단말의 인터넷 공유를 가능케 합니다.
- PAT는 소스 포트를 변환해 다수의 세션을 하나의 공인 IP에 매핑합니다.
- 포트 포워딩 설정으로 외부에서 내부 서버로의 접근을 허용할 수 있습니다.
- NAT는 IPv6에서 필수는 아닙니다(전역 주소 공간이 넓음). 또한 NAT는 ARP의 대체 기술이 아닙니다(ARP는 동일 망에서 IP→MAC 해석 담당).

<a id="ans-01-3-tcp-udp"></a>
## 01-3 TCP, UDP 정답 및 해설

### 문제 1
문제: TCP 3-way 핸드셰이크의 올바른 순서는?

정답: SYN → SYN-ACK → ACK

해설: 클라이언트가 SYN으로 시작하고, 서버가 SYN-ACK로 응답, 마지막으로 클라이언트가 ACK를 보내며 연결이 성립됩니다.

### 문제 2
문제: 다음 중 TCP가 제공하는 기능은?

정답: 순서 보장과 재전송 메커니즘

해설: TCP는 순서 보장과 ACK/재전송을 제공합니다. 브로드캐스트/멀티캐스트는 기본 제공하지 않으며, 핸드셰이크 없이 전송하는 것은 UDP의 특성입니다.

### 문제 3 (복수 응답)
문제: 다음 중 UDP의 특징과 활용에 대해 옳은 것을 모두 고르시오.

정답: 연결 설정 없이 전송하며 오버헤드가 낮다; 실시간 스트리밍이나 온라인 게임에 자주 사용된다; DNS 질의에 흔히 사용된다

해설:
- UDP는 비연결형으로 지연과 오버헤드가 낮습니다.
- 약간의 손실을 허용하는 실시간 애플리케이션에서 자주 사용됩니다.
- DNS 쿼리는 보통 UDP를 사용합니다(단, 큰 응답이나 특수 상황에서 TCP 사용 가능). HTTP/3는 QUIC(UDP 기반)이므로 "UDP와 무관"이 아닙니다.

<a id="ans-01-4-port"></a>
## 01-4 PORT 정답 및 해설

### 문제 1
문제: 포트 범위 분류에 대한 설명으로 옳은 것은?

정답: Dynamic Ephemeral은 49152~65535 이다

해설: IANA 권장 에페머럴 포트 범위는 49152~65535입니다. Well-known은 0~1023, Registered는 1024~49151입니다. 운영체제 기본 범위는 다를 수 있으나 개념적으로는 이 구분을 따릅니다.

### 문제 2
문제: 다음 중 소켓과 연결 식별에 대한 올바른 설명은?

정답: 클라이언트는 에페머럴 포트를 사용해 각 연결을 구분한다; 같은 서버 포트로 동시에 여러 연결이 가능한 이유는 소스 IP와 포트가 달라 4튜플이 고유하기 때문이다

해설:
- 서버의 한 리스닝 포트에도 다수의 동시 연결을 처리할 수 있습니다. 각 연결은 소스 IP/포트가 달라 4튜플로 구분됩니다.
- 연결의 고유 식별을 IP 주소만으로 할 수는 없습니다. 포트와 전송 프로토콜까지 포함해야 합니다.

### 문제 3 (복수 응답)
문제: NAT와 포트 포워딩에 대해 옳은 것을 모두 고르시오.

정답: PAT는 소스 포트를 변경해 여러 내부 연결을 하나의 공인 IP에 매핑한다; 외부에서 내부 웹 서버로 접근하려면 포트 포워딩 등 매핑 규칙이 필요하다; 같은 공인 IP의 서로 다른 포트에 서로 다른 내부 서비스(포트)를 매핑할 수 있다

해설:
- PAT는 포트 번호를 변환해 다수의 내부 세션을 하나의 공인 IP로 구분합니다.
- 외부 접근을 위해서는 NAT 장비에서 공인 IP의 특정 포트를 내부 IP:포트로 포워딩해야 합니다.
- NAT 환경에서도 포트는 핵심 개념이며, DNS는 보통 UDP 53을 사용하지만 항상 TCP 53만을 사용하는 것은 아닙니다. 상황에 따라 TCP도 사용됩니다.


<a id="ans-01-5-dns"></a>
## 01-5 DNS 정답 및 해설

### 문제 1
문제: DNS 조회 흐름에 대한 설명으로 옳은 것은?

정답: 리커시브 리졸버는 최종 응답을 얻기 위해 루트→TLD→권한 서버를 순회할 수 있다

해설: 일반적으로 브라우저/OS의 스텁 리졸버는 로컬/리커시브 리졸버에 재귀 요청을 보내고, 리커시브 리졸버가 루트→TLD→권한 서버를 따라가며 최종 응답을 구해 캐시한 뒤 반환합니다. 브라우저가 직접 루트에 질의하지 않습니다. NS 레코드는 네임서버 권한 위임 정보를 담으며, TTL은 캐싱 동작에 큰 영향을 줍니다.

### 문제 2
문제: 다음 중 레코드 타입과 설명의 연결이 올바른 것은?

정답: MX: 메일 수신 서버 도메인을 지정한다

해설: MX는 메일 교환 서버 도메인을 지정하며 우선순위를 포함합니다. CNAME은 IP를 직접 제공하지 않고 정식 이름으로 별칭을 연결합니다. TXT는 SPF/도메인 검증 등 텍스트를 담고, SOA는 존의 시작 정보와 시리얼/타이머 등을 담습니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: 일반 DNS 질의는 보통 UDP 53을 사용한다; 큰 응답이거나 영역 전송은 TCP 53이 사용될 수 있다; TTL이 짧으면 변경 사항이 더 빠르게 전파된다

해설:
- 보통의 질의/응답은 지연과 오버헤드를 줄이기 위해 UDP 53으로 수행됩니다(EDNS로 확장 가능).
- 응답이 크거나 영역 전송(AXFR/IXFR) 같은 작업에는 TCP 53이 사용될 수 있습니다.
- TTL이 짧으면 캐시 유효기간이 짧아져 변경 전파가 빨라집니다. CNAME과 A를 동일 이름에 동시에 둘 수는 없습니다. 리커시브 리졸버는 성능 향상을 위해 응답을 캐시합니다.


<a id="ans-02-1-uri"></a>
## 02-1 URI 정답 및 해설

### 문제 1
문제: 다음 중 URI의 구성 요소에 대한 설명으로 옳은 것은?

정답: 스키마와 호스트는 대소문자를 구분하지 않는다

해설:
- 프래그먼트는 클라이언트 전용으로 서버 라우팅에 사용되지 않으며 HTTP 요청에 포함되지 않습니다.
- `userinfo`는 보안/로그 노출 문제로 웹에서 사용이 권장되지 않습니다.
- 쿼리에서 `&`, `=`는 구분자로 쓰이므로 값에 포함할 때는 퍼센트 인코딩해야 합니다.
- 스키마와 호스트는 대소문자를 구분하지 않습니다. 반면 경로는 서버 구현에 따라 대소문자를 구분할 수 있습니다.

### 문제 2
문제: 다음 중 퍼센트 인코딩과 관련하여 옳은 것은?

정답: `/` 문자는 경로 구분자이므로 값으로 쓰려면 `%2F`로 인코딩해야 한다

해설:
- 공백은 일반적으로 `%20`로 인코딩합니다. `+`는 application/x-www-form-urlencoded의 쿼리 컨텍스트에서 공백처럼 해석될 수 있지만 RFC3986 일반 규칙 그 자체는 아닙니다.
- `/`는 경로 구분자이며, 값에 포함하려면 `%2F`로 인코딩해야 안전합니다.
- 한글 등 비ASCII 문자는 UTF-8 바이트로 퍼센트 인코딩해야 합니다.
- 프래그먼트는 서버로 전송되지 않으므로 서버 보관 전 디코딩 요구사항이 성립하지 않습니다.

### 문제 3 (복수 응답)
문제: 다음 중 옳은 것을 모두 고르시오.

정답: URL은 URI의 부분집합이다, URN은 리소스 위치가 바뀌어도 동일 식별자로 쓸 수 있다, 경로는 리소스 식별, 쿼리는 필터/정렬/페이징 등 옵션에 적합하다, 호스트에 한글 도메인을 사용할 때 내부적으로 Punycode가 사용될 수 있다

해설:
- URL ⊂ URI: URL은 위치를 나타내는 URI의 한 종류입니다.
- URN은 위치와 독립적인 이름입니다(예: ISBN). 위치 변경과 무관하게 동일 식별자가 유지됩니다.
- 경로는 리소스를 식별하고, 쿼리는 필터/정렬/페이지네이션 같은 옵션 전달에 적합합니다.
- HTTPS의 기본 포트는 443으로, 80은 HTTP의 기본 포트입니다.
- 국제화 도메인 이름(IDN)은 Punycode로 변환되어 DNS에 전송됩니다.
